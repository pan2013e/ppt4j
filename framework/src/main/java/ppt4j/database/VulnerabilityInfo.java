package ppt4j.database;

import ppt4j.annotation.Nullable;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.ToString;
import lombok.extern.log4j.Log4j;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.Objects;

@JsonIgnoreProperties(ignoreUnknown = true)
@ToString
@Log4j
@SuppressWarnings("unused")
public class VulnerabilityInfo {

    /**
     * Creates a VulnerabilityInfo object by parsing JSON data from the InputStream.
     *
     * @param stream the InputStream containing the JSON data
     * @return a VulnerabilityInfo object created from the JSON data
     * @throws IOException if an I/O error occurs while reading the input stream
     */
    public static VulnerabilityInfo fromJSON(InputStream stream)
                throws IOException {
            // Create a new ObjectMapper instance
            return new ObjectMapper()
                    // Read all bytes from the input stream and map them to a VulnerabilityInfo object
                    .readValue(stream.readAllBytes(), VulnerabilityInfo.class);
        }

    /**
     * Writes the JSON representation of the current object to a file specified by the given path.
     * 
     * @param path the path of the file where the JSON representation will be written
     * @throws IOException if an I/O error occurs when writing the JSON representation to the file
     */
    public void dumpJSON(String path) throws IOException {
        // Create a new ObjectMapper instance
        ObjectMapper objectMapper = new ObjectMapper();
        
        // Write the JSON representation of the current object to the file specified by the path
        objectMapper.writeValue(new File(path), this);
    }

    public String   vul_id;
    public String   cve_id;
    public String   project;
    public String   project_url;
    public String   build_system;
    public String   src_classes_dir;
    public String   human_patch_url;
    public String   fixing_commit_hash;

    @Nullable
    public boolean  should_scan_all_modules;
    @Nullable
    public String[] third_party_src_dirs;
    @Nullable
    public String[] third_party_lib_dirs;
    @Nullable
    public String   src_top_level_dir;
    
    /**
     * Checks if all non-nullable fields in the current object are empty (null or empty string).
     * Non-nullable fields are determined by the absence of the Nullable annotation.
     * 
     * @return true if all non-nullable fields are empty, false otherwise
     */
    public boolean isEmpty() {
        // Get all declared fields of the current object
        Field[] fields = this.getClass().getDeclaredFields();
        
        // Iterate through each field
        for (Field field : fields) {
            // Check if the field has the Nullable annotation, if so, skip to the next field
            if(field.isAnnotationPresent(Nullable.class)) {
                continue;
            }
            
            try {
                // Check if the field value is null or an empty string
                if(field.get(this) == null || Objects.equals(field.get(this), "")) {
                    return true; // Return true if any non-nullable field is empty
                }
            } catch (IllegalAccessException e) {
                log.error(e); // Log any illegal access exceptions
                return true; // Return true if an exception occurs
            }
        }
        
        return false; // Return false if all non-nullable fields are not empty
    }

}
